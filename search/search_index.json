{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-]","pipeline":["stemmer"]},"docs":[{"location":"","title":"Home","text":""},{"location":"api/opengles/opengles/","title":"OpenGL ES","text":""},{"location":"api/opengles/extension/GL_EXT_memory_object/","title":"Vulkan\u200b\u548c\u200bOpenGL ES\u200b\u901a\u8fc7\u200bmemory object\u200b\u5171\u4eab\u200b\u6570\u636e","text":""},{"location":"api/opengles/extension/GL_EXT_memory_object/#opengl-es","title":"OpenGL ES\u200b\u6269\u5c55","text":""},{"location":"api/opengles/extension/GL_EXT_memory_object/#gl_ext_memory_object","title":"GL_EXT_memory_object","text":"<ul> <li>https://registry.khronos.org/OpenGL/extensions/EXT/EXT_external_objects.txt</li> </ul> <p>Memory object</p> <pre><code>void CreateMemoryObjectsEXT(sizei n, uint *memoryObjects);\n\nvoid DeleteMemoryObjectsEXT(sizei n, const uint *memoryObjects);\n\nboolean IsMemoryObjectEXT(uint memoryObject);\n\nvoid TexStorageMem2DEXT(enum target,\n                        sizei levels,\n                        enum internalFormat,\n                        sizei width,\n                        sizei height,\n                        uint memory, // memory object\n                        uint64 offset);\n\nvoid BufferStorageMemEXT(enum target,\n                         sizeiptr size,\n                         uint memory, // memory object\n                         uint64 offset);\n</code></pre>"},{"location":"api/opengles/extension/GL_EXT_memory_object/#gl_ext_memory_object_fd","title":"GL_EXT_memory_object_fd","text":"<ul> <li>https://registry.khronos.org/OpenGL/extensions/EXT/EXT_external_objects_fd.txt</li> </ul> <pre><code>#define HANDLE_TYPE_OPAQUE_FD_EXT 0x9586\nvoid ImportMemoryFdEXT(uint memory,\n                       uint64 size,\n                       enum handleType,\n                       int fd);\n</code></pre>"},{"location":"api/opengles/extension/GL_EXT_memory_object/#vulkan","title":"Vulkan\u200b\u6269\u5c55","text":""},{"location":"api/opengles/extension/GL_EXT_memory_object/#vk_khr_external_memory","title":"VK_KHR_external_memory","text":"<ul> <li>https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory.html</li> </ul>"},{"location":"api/opengles/extension/GL_EXT_memory_object/#vk_khr_external_memory_fd","title":"VK_KHR_external_memory_fd","text":"<ul> <li>https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_external_memory_fd.html</li> <li>An application may wish to reference device memory <code>in multiple Vulkan logical devices or instances</code>, <code>in multiple processes</code>, and/or <code>in multiple APIs</code>.</li> <li>This extension enables an application to <code>export POSIX file descriptor handles</code> from Vulkan memory objects and to import Vulkan memory objects from POSIX file descriptor handles exported from other Vulkan memory objects or from similar resources in other APIs.</li> </ul> <pre><code>VkResult vkGetMemoryFdKHR(\n    VkDevice                                    device,\n    const VkMemoryGetFdInfoKHR*                 pGetFdInfo,\n    int*                                        pFd);\n\ntypedef struct VkMemoryGetFdInfoKHR {\n    VkStructureType                       sType;\n    const void*                           pNext;\n    VkDeviceMemory                        memory;\n    VkExternalMemoryHandleTypeFlagBits    handleType;\n} VkMemoryGetFdInfoKHR;\n</code></pre> <ul> <li><code>handleType</code> must be <code>VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT</code> or <code>VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT</code></li> <li><code>VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT</code> specifies a <code>POSIX file descriptor handle</code> that has only limited valid usage outside of Vulkan and other compatible APIs. It must be compatible with the POSIX system calls dup, dup2, close, and the non-standard system call dup3. Additionally, it must be transportable over a socket using an SCM_RIGHTS control message. It owns a reference to the underlying memory resource represented by its Vulkan memory object.</li> <li><code>VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT</code> is a file descriptor for a <code>Linux dma_buf</code>. It owns a reference to the underlying memory resource represented by its Vulkan memory object.</li> </ul>"},{"location":"api/opengles/extension/GL_EXT_memory_object/#_1","title":"\u53c2\u8003","text":""},{"location":"api/opengles/extension/GL_EXT_memory_object/#vulkan-opengl","title":"Vulkan &amp; OpenGL \u200b\u7eb9\u7406\u200b\u5171\u4eab\u200b\u4e0e\u200b\u540c\u6b65","text":"<ul> <li>https://zhuanlan.zhihu.com/p/620899883</li> <li>\u200b\u4ee3\u7801\u200b\uff1ahttps://github.com/keith2018/SoftGLRender</li> </ul> <pre><code>// \u200b\u4ece\u200b\u521b\u5efa\u200b\u597d\u200b\u7684\u200b vkMemory \u200b\u5bf9\u8c61\u200b\u4e2d\u200b\u83b7\u53d6\u200b\u5171\u4eab\u200b\u7528\u200b\u7684\u200b handle\nVkMemoryGetHandleInfo memoryGetInfo{};\nmemoryGetInfo.sType = VK_STRUCTURE_TYPE_MEMORY_GET_HANDLE_INFO;\nmemoryGetInfo.memory = memory;\nmemoryGetInfo.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE;\nVK_CHECK(vkGetMemoryHandle(device_, &amp;memoryGetInfo, &amp;sharedMemory_.handle));\n\n// \u200b\u62ff\u5230\u200b handle \u200b\u540e\u200b\uff0c\u200b\u5c31\u200b\u53ef\u4ee5\u200b\u7ed9\u200b\u5230\u200b OpenGL \u200b\u8fdb\u884c\u200b Memory Object \u200b\u7684\u200b\u521b\u5efa\u200b\nGL_CHECK(glCreateMemoryObjectsEXT(1, &amp;sharedMemory_.glRef));\nGL_CHECK(glImportMemory(sharedMemory_.glRef, sharedMemory_.allocationSize, GL_HANDLE_TYPE, sharedMemory_.handle));\n\n// \u200b\u6700\u540e\u200b\uff0c\u200b\u6211\u4eec\u200b\u5c06\u200b OpenGL \u200b\u7684\u200b Memory Object \u200b\u8bbe\u7f6e\u200b\u5230\u200b Texture\nGL_CHECK(glTextureStorageMem2DEXT(texture, levels, internalFormat, width, height, sharedMemory_.glRef, 0));\n\n// \u200b\u5230\u200b\u6b64\u200b\uff0c\u200b\u6211\u4eec\u200b\u5c31\u200b\u5b8c\u6210\u200b\u4e86\u200b\u7eb9\u7406\u200b\u5171\u4eab\u200b\u7684\u200b\u5168\u8fc7\u7a0b\u200b\uff0c\u200b\u5f53\u7136\u200b\u5171\u4eab\u200b\u7684\u200b Memory \u200b\u9664\u4e86\u200b\u7528\u4e8e\u200b\u7eb9\u7406\u200b\uff0c\u200b\u4e5f\u200b\u53ef\u4ee5\u200b\u7528\u4e8e\u200b Buffer \u200b\u5bf9\u8c61\u200b\n</code></pre>"},{"location":"api/opengles/extension/GL_EXT_memory_object/#opengl-and-vulkan-interoperability-on-linux","title":"OpenGL and Vulkan Interoperability on Linux","text":"<ul> <li>https://eleni.mutantstargoat.com/hikiko/category/opengl-and-vulkan-interoperability/</li> </ul>"},{"location":"api/opengles/extension/GL_EXT_memory_object/#opengl-and-vulkan-interoperability-on-linux-part-1-introduction","title":"[OpenGL and Vulkan Interoperability on Linux] Part 1: Introduction","text":"<ul> <li>https://eleni.mutantstargoat.com/hikiko/gl-vk-interop-intro/</li> </ul> <p>In order to reuse Vulkan allocated resources we usually need to:</p> <ol> <li>Use the appropriate flags at allocation to allow \u201cexternal\u201d (OpenGL) access to them.</li> <li>Use the <code>EXT_external_objects_fd</code> provided functions to take a file descriptor that points to that memory from Vulkan and give it to OpenGL in order to gain access too.</li> <li>Create an OpenGL object that corresponds to that memory. Use that object like an ordinary OpenGL object (such as texture, buffer, depth or stencil buffer).</li> <li>Synchronize the access to that object with a special type of semaphores when necessary (for example when OpenGL must wait for Vulkan to finish an operation before it uses the object or the opposite).</li> </ol> <p><code>EXT_external_objects</code> provide all the functions for the steps 3-4, step 1 is done in Vulkan, and <code>EXT_external_objects_fd</code> is required for step 2.</p>"},{"location":"api/opengles/extension/GL_EXT_memory_object/#opengl-and-vulkan-interoperability-on-linux-part-2-using-opengl-to-draw-on-vulkan-textures","title":"[OpenGL and Vulkan Interoperability on Linux] Part 2: Using OpenGL to draw on Vulkan textures.","text":"<ul> <li>https://eleni.mutantstargoat.com/hikiko/vk-gl-interop-2/</li> </ul>"},{"location":"api/vulkan/vulkan/","title":"Vulkan","text":""},{"location":"graphics/raytracing/","title":"Ray Tracing","text":""},{"location":"graphics/raytracing/#tutorial-ray-tracing-in-one-weekend","title":"Tutorial: Ray Tracing in One Weekend","text":"<ul> <li>Ray Tracing in One Weekend</li> <li>Ray Tracing: The Next Week</li> <li>Ray Tracing: The Rest of Your Life</li> </ul>"},{"location":"graphics/raytracing/#khronos-ray-tracing","title":"Khronos Ray Tracing","text":"<ul> <li>Ray Tracing In Vulkan</li> </ul>"},{"location":"graphics/raytracing/#nvidia-ray-tracing","title":"NVIDIA Ray Tracing","text":"<ul> <li>NVIDIA Vulkan Ray Tracing Tutorial</li> </ul>"},{"location":"graphics/texture_compression/","title":"Texture Compression","text":""},{"location":"graphics/texture_compression/#ktx","title":"KTX","text":"<ul> <li>https://www.khronos.org/ktx/</li> <li><code>KTX (Khronos Texture)</code> is an efficient, lightweight <code>container format</code> for reliably distributing GPU textures to diverse platforms and applications. </li> <li>The contents of a KTX file can range from a simple base-level <code>2D texture</code> to a <code>cubemap array texture with mipmaps</code>. </li> <li>KTX files hold all the parameters needed for efficient texture loading into 3D APIs such as OpenGL\u00ae and Vulkan\u00ae, including access to individual mipmap levels</li> <li><code>KTX 2.0</code> adds support for <code>Basis Universal</code> supercompressed GPU textures</li> <li>Khronos has released the <code>KHR_texture_basisu</code> extension that enables <code>glTF to contain KTX 2.0 textures</code>, resulting in universally distributable glTF assets that reduce download size and use natively supported texture formats to reduce GPU memory size and boost rendering speed on diverse devices and platforms.</li> </ul>"},{"location":"graphics/texture_compression/#basis-universal","title":"Basis Universal","text":"<ul> <li>https://github.com/BinomialLLC/basis_universal</li> <li>Basis Universal is a \"supercompressed\" GPU texture data interchange system</li> <li> <p>Supports two highly compressed intermediate file formats</p> </li> <li> <p><code>.basis</code> </p> </li> <li><code>.KTX2</code> open standard from the Khronos Group</li> <li>Can be quickly transcoded to a very wide variety of GPU compressed and uncompressed pixel format</li> <li> <p>Supports two modes</p> </li> <li> <p>UASTC</p> <ul> <li>high quality mode</li> <li>based off the <code>UASTC</code> compressed texture format</li> <li>for extremely high quality (similar to BC7 quality)</li> </ul> </li> <li>ETC1S<ul> <li>lower quality mode</li> <li>based off a subset of <code>ETC1</code></li> <li>for very small files</li> </ul> </li> </ul>"},{"location":"performance/mobile_game_performance_optimization_techniques/","title":"\u79fb\u52a8\u6e38\u620f\u200b\u6027\u80fd\u200b\u4f18\u5316\u200b\u901a\u7528\u200b\u6280\u6cd5","text":"<ul> <li>https://www.cnblogs.com/timlly/p/10463467.html</li> </ul>"},{"location":"performance/amd/amd_rdna_performance_guide/","title":"AMD RDNA Performance Guide","text":"<ul> <li>https://gpuopen.com/learn/rdna-performance-guide/</li> </ul>"},{"location":"performance/apple/apple_openes_design_guidelines/","title":"# OpenGL ES Design Guidelines","text":"<ul> <li>https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/OpenGLESApplicationDesign/OpenGLESApplicationDesign.html</li> </ul>"},{"location":"performance/arm/arm_gpu_best_practices/","title":"Qualcomm Adreno GPU Best Practices","text":"<ul> <li>https://developer.qualcomm.com/sites/default/files/docs/adreno-gpu/snapdragon-game-toolkit/gdg/gpu/best_practices.html</li> </ul>"},{"location":"performance/qualcomm/qualcomm_adreno_gpu_best_practices/","title":"Arm GPU Best Practices Developer Guide","text":"<ul> <li>https://developer.arm.com/documentation/101897/latest/</li> </ul>"}]}